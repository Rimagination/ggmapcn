title = "Automatic Clipping Prevention",
subtitle = "No manual 'pad_x' needed, the function adjusts itself!"
)
# --- Print the result ---
print(p1_now_works)
# =============================================================================
# 3. The core drawing function (FINAL CORRECTED VERSION)
# =============================================================================
scalebar_grobs_segment <- function(
params, style = c("ticks", "bar", "segment"), location = c("bl", "br", "tr", "tl"),
bar_cols = c("black", "white"), line_width = 1, line_col = "black",
height = unit(0.25, "cm"), pad_x = unit(0.25, "cm"),
pad_y = unit(0.25, "cm"), text_pad = unit(0.15, "cm"), text_cex = 0.7,
text_col = "black", text_face = NULL, text_family = "", tick_height = 0.6,
segments = NULL, label_show = "all", minor_tick_height = 0.8
) {
style <- match.arg(style); location <- match.arg(location)
adj_x <- as.numeric(grepl("r", location)); adj_y <- as.numeric(grepl("t", location))
width <- unit(params$widthnpc, "npc")
origin_x <- unit(adj_x, "npc") - adj_x * width + (0.5 - adj_x) * 2 * pad_x
origin_y <- unit(adj_y, "npc") - adj_y * height + (0.5 - adj_y) * 2 * pad_y
if (style == "segment") {
# (Steps 1-4 are the same as before)
n_divs <- if (!is.null(segments) && is.numeric(segments)) as.integer(segments) else params$majordivs
if (n_divs < 1) n_divs <- 1
n_ticks <- n_divs + 1
tick_interval_npc <- params$widthnpc / n_divs
tick_pos_npc <- (0:n_divs) * tick_interval_npc
tick_interval_u <- params$widthu / n_divs
all_labels <- prettyNum((0:n_divs) * tick_interval_u, digits = 10)
tick_height_ratios <- rep(minor_tick_height, n_ticks)
tick_height_ratios[1] <- 1
tick_height_ratios[n_ticks] <- 1
if (n_divs %% 2 == 0 && n_divs > 0) {
mid_point_index <- (n_divs / 2) + 1
tick_height_ratios[mid_point_index] <- 1
}
tick_y1 <- origin_y + height * tick_height_ratios
indices_to_show <- integer(0)
if (is.character(label_show)) {
if (label_show == "all") indices_to_show <- 1:n_ticks
else if (label_show == "ends") indices_to_show <- c(1, n_ticks)
else if (label_show == "major") indices_to_show <- which(tick_height_ratios == 1)
} else if (is.numeric(label_show) && length(label_show) == 1) {
every_n <- as.integer(label_show); if (every_n < 1) every_n <- 1
indices_to_show <- union(seq(1, n_ticks, by = every_n), c(1, n_ticks))
} else if (is.numeric(label_show)) {
indices_to_show <- unique(as.integer(label_show[label_show >= 1 & label_show <= n_ticks]))
}
labels_to_show <- all_labels[indices_to_show]
tick_pos_to_show <- tick_pos_npc[indices_to_show]
labels_with_unit <- labels_to_show
if (length(labels_with_unit) > 0 && n_ticks %in% indices_to_show) {
last_label_index <- length(labels_with_unit)
labels_with_unit[last_label_index] <- paste(labels_to_show[last_label_index], params$unit)
}
# --- CORRECTED: Automatic adjustment to prevent label clipping ---
gp <- grid::gpar(cex = text_cex, col = text_col, fontfamily = text_family, fontface = text_face)
# If right-aligned, check the last label and shift left if needed
if (adj_x == 1 && n_ticks %in% indices_to_show) {
last_label <- labels_with_unit[length(labels_with_unit)]
# Create a temporary text grob to measure its width correctly
last_label_grob <- grid::textGrob(label = last_label, gp = gp)
last_label_width <- grid::grobWidth(last_label_grob)
# Shift the origin by half of the measured width
origin_x <- origin_x - 0.5 * last_label_width
}
# If left-aligned, check the first label and shift right if needed
if (adj_x == 0 && 1 %in% indices_to_show) {
first_label <- labels_with_unit[1]
# Create a temporary text grob to measure its width correctly
first_label_grob <- grid::textGrob(label = first_label, gp = gp)
first_label_width <- grid::grobWidth(first_label_grob)
# Shift the origin by half of the measured width
origin_x <- origin_x + 0.5 * first_label_width
}
# --- End of corrected adjustment logic ---
# 5. Draw graphical elements (grobs)
horizontal_line <- grid::segmentsGrob( x0 = origin_x, y0 = origin_y, x1 = origin_x + width, y1 = origin_y, gp = grid::gpar(lwd = line_width, col = line_col))
vertical_ticks <- grid::segmentsGrob( x0 = origin_x + unit(tick_pos_npc, "npc"), y0 = origin_y, x1 = origin_x + unit(tick_pos_npc, "npc"), y1 = tick_y1, gp = grid::gpar(lwd = line_width, col = line_col))
bar_grob <- grid::gList(horizontal_line, vertical_ticks)
text_grob <- grid::textGrob( label = labels_with_unit, x = origin_x + unit(tick_pos_to_show, "npc"), y = origin_y + height + text_pad, hjust = 0.5, vjust = 0, gp = gp)
return(grid::gList(bar_grob, text_grob))
} else {
# (Fallback logic for "bar" and "ticks" styles remains unchanged)
text_origin_x <- unit(adj_x, "npc") + (0.5 - adj_x) * 2 * (pad_x + text_pad + width); text_origin_y <- unit(adj_y, "npc") + (0.5 - adj_y) * 2 * (pad_y + 0.5 * height)
if (style == "bar") { bar_grob <- grid::rectGrob(x = origin_x + unit((seq_len(params$majordivs) - 1) * params$majordivnpc, "npc"), y = origin_y, width = unit(params$majordivnpc, "npc"), height = height, hjust = 0, vjust = 0, gp = grid::gpar(fill = rep(bar_cols, length.out = params$majordivs), col = line_col, lwd = line_width))
} else if (style == "ticks") { bar_grob <- grid::gList(grid::segmentsGrob(x0 = origin_x + unit((seq_len(params$majordivs + 1) - 1) * params$majordivnpc, "npc"), y0 = origin_y, x1 = origin_x + unit((seq_len(params$majordivs + 1) - 1) * params$majordivnpc, "npc"), y1 = origin_y + grid::unit.c(height, rep(height * tick_height, params$majordivs - 1), height), gp = grid::gpar(lwd = line_width, col = line_col)), grid::segmentsGrob(x0 = origin_x, y0 = origin_y, x1 = origin_x + width, y1 = origin_y, gp = grid::gpar(lwd = line_width, col = line_col))) }
text_grob <- grid::textGrob(label = params$labeltext, x = text_origin_x, y = text_origin_y, hjust = adj_x, vjust = 0.5, gp = grid::gpar(cex = text_cex, col = text_col, fontfamily = text_family, fontface = text_face)); return(grid::gList(bar_grob, text_grob))
}
}
# After defining the functions with the corrected code above...
# Prepare Data
nc <- st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc_utm <- st_transform(nc, 32617)
# Create a Base Plot
p_base <- ggplot() +
geom_sf(data = nc_utm, aes(fill = AREA)) +
theme_minimal() +
theme(legend.position = "none")
# Run the test plot
p1_now_works <- p_base +
annotation_scale_segment(
location = "br",
style = "segment",
plot_unit = "m"
) +
labs(
title = "Automatic Clipping Prevention (Corrected)",
subtitle = "This should now work perfectly!"
)
# Print the final result
print(p1_now_works)
# =============================================================================
# 4. Unmodified helper functions... (NOW MODIFIED WITH A WARNING)
# =============================================================================
# This helper function calculates the scale bar parameters
scalebar_params <- function(
sf_bbox, plotunit = NULL, sf_crs = NULL, widthhint = 0.25,
unitcategory = c("metric", "imperial")
) {
unitcategory <- match.arg(unitcategory)
# For geographic CRS (latitude/longitude)
if(!is.null(sf_crs) && is.na(sf::st_crs(sf_crs)$units)) {
point_coords <- expand.grid(
x = c(sf_bbox["xmin"], sf_bbox["xmax"]),
y = c(sf_bbox["ymin"], mean(c(sf_bbox["ymin"], sf_bbox["ymax"])), sf_bbox["ymax"])
)
latlon_coords <- sf::st_coordinates(
sf::st_transform(
sf::st_as_sf(point_coords, coords = c("x", "y"), crs = sf_crs),
4326
)
)
widthbottom <- .geodist(latlon_coords[1,], latlon_coords[2,])
widthmiddle <- .geodist(latlon_coords[3,], latlon_coords[4,])
widthtop <- .geodist(latlon_coords[5,], latlon_coords[6,])
# --- NEW: Warning for potential inaccuracy in geographic CRS ---
widths <- c(widthbottom, widthmiddle, widthtop)
variation <- (max(widths) - min(widths)) / min(widths)
if (variation > 0.15) {
warning(
"Scale bar may be inaccurate due to map projection.\n",
"The map spans a large latitudinal area in a geographic CRS.\n",
"Using distance at map center. For accurate scales, reproject your data.",
call. = FALSE
)
}
# --- End of new warning logic ---
# Use the width at the center for calculation
plotwidth <- widthmiddle
# For projected CRS (units are typically meters)
} else if(!is.null(plotunit)) {
plotwidth <- (sf_bbox["xmax"] - sf_bbox["xmin"])
} else {
stop("Must supply 'plot_unit' for a projected CRS, or a valid 'crs' for a geographic CRS.")
}
# (The rest of the function remains the same)
if(unitcategory == "metric") {
unitoptions <- c("km", "m"); unitconversion <- c(1000, 1)
} else {
unitoptions <- c("mi", "ft"); unitconversion <- c(1609.34, 0.3048)
}
if(is.null(plotunit)) { plotunit <- "m" }
plotwidth <- plotwidth / unitconversion[unitoptions == plotunit]
targetwidth <- plotwidth * widthhint
log10_targetwidth <- log10(targetwidth)
powerof10 <- floor(log10_targetwidth)
majordivs <- c(1, 2, 5, 10)[which.min(abs(c(1, 2, 5, 10) * (10 ^ powerof10) - targetwidth))]
widthu <- majordivs * (10 ^ powerof10)
if(widthu >= 1000 && (unitcategory == "metric") && (plotunit == "m")) {
unit <- "km"; widthu <- widthu / 1000
} else if(widthu >= 5280 && (unitcategory == "imperial") && (plotunit == "ft")) {
unit <- "mi"; widthu <- widthu / 5280
} else { unit <- plotunit }
majordivs <- c(1, 2, 5, 10)[which.min(abs(c(1, 2, 5, 10) * (10 ^ powerof10) - targetwidth))]
if(widthu < 2 && majordivs == 5) { majordivs <- 4
} else if(widthu < 1.5 && majordivs == 2) { majordivs <- 3 }
return(list(widthnpc = (widthu / plotwidth) * (unitconversion[unitoptions == unit] / unitconversion[unitoptions == plotunit]), widthu = widthu, majordivs = majordivs, majordivnpc = (widthu / plotwidth) * (unitconversion[unitoptions == unit] / unitconversion[unitoptions == plotunit]) / majordivs, unit = unit, labeltext = paste(widthu, unit)))
}
# (确保你已经运行了所有更新后的函数定义)
# 1. Create a "dummy" spatial object with a large latitudinal span
large_area_df <- data.frame(
lon = c(-120, 120, 120, -120, -120),
lat = c(0, 0, 70, 70, 0) # Spans from Equator to high north
)
large_area_sf <- st_as_sf(large_area_df, coords = c("lon", "lat"), crs = 4326)
large_area_polygon <- st_combine(large_area_sf) %>% st_cast("POLYGON")
# 2. Create the plot. No projection is applied.
# This will trigger the warning when the scale bar is added.
p_warning <- ggplot() +
geom_sf(data = large_area_polygon, fill = "lightblue") +
# Use the function on a geographic CRS plot
annotation_scale_segment(location = "bl") +
labs(title = "Plotting a large latitudinal area")
# 3. Print the plot and observe the console
print(p_warning)
# =============================================================================
# 4. Helper function `scalebar_params` (FINAL CORRECTED VERSION)
# =============================================================================
scalebar_params <- function(
sf_bbox, plotunit = NULL, sf_crs = NULL, widthhint = 0.25,
unitcategory = c("metric", "imperial")
) {
unitcategory <- match.arg(unitcategory)
# --- CORRECTED LOGIC: Use sf::st_is_longlat() for a robust CRS check ---
# This is the officially recommended way to check for a geographic CRS.
if(!is.null(sf_crs) && sf::st_is_longlat(sf_crs)) {
point_coords <- expand.grid(
x = c(sf_bbox["xmin"], sf_bbox["xmax"]),
y = c(sf_bbox["ymin"], mean(c(sf_bbox["ymin"], sf_bbox["ymax"])), sf_bbox["ymax"])
)
latlon_coords <- sf::st_coordinates(
sf::st_transform(
sf::st_as_sf(point_coords, coords = c("x", "y"), crs = sf_crs),
4326
)
)
widthbottom <- .geodist(latlon_coords[1,], latlon_coords[2,])
widthmiddle <- .geodist(latlon_coords[3,], latlon_coords[4,])
widthtop <- .geodist(latlon_coords[5,], latlon_coords[6,])
# Warning for potential inaccuracy in geographic CRS
widths <- c(widthbottom, widthmiddle, widthtop)
variation <- (max(widths) - min(widths)) / min(widths)
if (variation > 0.15) {
warning(
"Scale bar may be inaccurate due to map projection.\n",
"The map spans a large latitudinal area in a geographic CRS.\n",
"Using distance at map center. For accurate scales, reproject your data.",
call. = FALSE
)
}
plotwidth <- widthmiddle
} else if(!is.null(plotunit)) {
plotwidth <- (sf_bbox["xmax"] - sf_bbox["xmin"])
} else {
stop("Must supply 'plot_unit' for a projected CRS, or a valid 'crs' for a geographic CRS.")
}
# (The rest of the function remains the same)
if(unitcategory == "metric") {
unitoptions <- c("km", "m"); unitconversion <- c(1000, 1)
} else {
unitoptions <- c("mi", "ft"); unitconversion <- c(1609.34, 0.3048)
}
if(is.null(plotunit)) { plotunit <- "m" }
plotwidth <- plotwidth / unitconversion[unitoptions == plotunit]
targetwidth <- plotwidth * widthhint; log10_targetwidth <- log10(targetwidth); powerof10 <- floor(log10_targetwidth); majordivs <- c(1, 2, 5, 10)[which.min(abs(c(1, 2, 5, 10) * (10 ^ powerof10) - targetwidth))]; widthu <- majordivs * (10 ^ powerof10)
if(widthu >= 1000 && (unitcategory == "metric") && (plotunit == "m")) {
unit <- "km"; widthu <- widthu / 1000
} else if(widthu >= 5280 && (unitcategory == "imperial") && (plotunit == "ft")) {
unit <- "mi"; widthu <- widthu / 5280
} else { unit <- plotunit }
majordivs <- c(1, 2, 5, 10)[which.min(abs(c(1, 2, 5, 10) * (10 ^ powerof10) - targetwidth))]
if(widthu < 2 && majordivs == 5) { majordivs <- 4 } else if(widthu < 1.5 && majordivs == 2) { majordivs <- 3 }
return(list(widthnpc = (widthu / plotwidth) * (unitconversion[unitoptions == unit] / unitconversion[unitoptions == plotunit]), widthu = widthu, majordivs = majordivs, majordivnpc = (widthu / plotwidth) * (unitconversion[unitoptions == unit] / unitconversion[unitoptions == plotunit]) / majordivs, unit = unit, labeltext = paste(widthu, unit)))
}
# (确保您已运行了所有更新后的函数定义，包括上面最新的 scalebar_params)
# 1. Create a "dummy" spatial object with a large latitudinal span
large_area_df <- data.frame(lon = c(-120, 120, 120, -120, -120), lat = c(0, 0, 70, 70, 0))
large_area_sf <- st_as_sf(large_area_df, coords = c("lon", "lat"), crs = 4326)
large_area_polygon <- st_combine(large_area_sf) %>% st_cast("POLYGON")
# 2. This plot should now work perfectly AND show the warning
p_warning <- ggplot() +
geom_sf(data = large_area_polygon, fill = "lightblue") +
annotation_scale_segment(location = "bl") +
labs(title = "Plotting a large latitudinal area (Now works)")
# 3. Print the plot and observe the console
print(p_warning)
?annotation_scalebar
# --- 1. Prepare Data ---
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
nc_utm <- sf::st_transform(nc, 32617)
# --- 2. Create a Base Plot ---
p <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina", fill = "Area") +
ggplot2::theme_minimal()
p
# --- 3. Add the Scale Bar (using the default 'segment' style) ---
p +
annotation_scalebar(
location = "bl",
plot_unit = "m"
)
# --- 3. Add the Scale Bar (using the default 'segment' style) ---
p +
annotation_scalebar(
label_show = "major",
location = "bl",
plot_unit = "m"
)
# --- 3. Add the Scale Bar (using the default 'segment' style) ---
p +
annotation_scalebar(
label_show = "major",
location = "bl",
plot_unit = "m"
)
# --- 3. Add the Scale Bar (using the default 'segment' style) ---
p +
annotation_scalebar(
label_show = "ends",
location = "bl",
plot_unit = "m"
)
# --- 3. Add the Scale Bar (using the default 'segment' style) ---
p +
annotation_scalebar(
segments=4,
label_show = "ends",
location = "bl",
plot_unit = "m"
)
# --- Load Required Libraries ---
library(ggplot2)
library(sf)
# --- 1. Prepare Data ---
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
nc_utm <- sf::st_transform(nc, 32617)
# --- 2. Create a Base Plot ---
p <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina", fill = "Area") +
ggplot2::theme_minimal()
# --- 3. Add the Scale Bar (showcasing the new, clean default) ---
# The default 'style' is "segment" and default 'label_show' is "ends".
p +
annotation_scalebar(
location = "bl",
plot_unit = "m"
)
# --- Load Required Libraries ---
library(ggplot2)
library(sf)
# --- Prepare Data ---
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
nc_utm <- sf::st_transform(nc, 32617)
p <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina", fill = "Area") +
ggplot2::theme_minimal()
# --- Example 1: Default minimalist appearance ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "m"
)
# --- Example 2: Internationalization (Chinese labels) ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "m",
unit_labels = c(km = "千米", m = "米")
)
# --- Example 3: Forcing display unit to meters ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "m",
fixed_width = 100000,
display_unit = "m" # Override automatic promotion to 'km'
)
library(ggplot2)
library(sf)
# --- Prepare Data ---
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
nc_utm <- sf::st_transform(nc, 32617)
p <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina", fill = "Area") +
ggplot2::theme_minimal()
# --- Example 1: Default minimalist appearance ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "m"
)
# --- Example 2: Internationalization (Chinese labels) ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "m",
unit_labels = c(km = "千米", m = "米")
)
# --- Example 3: Forcing display unit to meters ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "m",
fixed_width = 100000,
display_unit = "m" # Override automatic promotion to 'km'
)
# --- Example 3: Forcing display unit to meters ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "km",
fixed_width = 100,
display_unit = "m"
)
# --- Example 3: Forcing display unit to meters ---
p +
annotation_scalebar(
location = "bl",
crs_unit = "km",
fixed_width = 300,
display_unit = "m"
)
# --- Load Required Libraries ---
if (require("ggplot2") && require("sf")) {
# --- Prepare Data ---
# Use the North Carolina shapefile included with the 'sf' package
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
# Transform to a projected CRS (UTM Zone 17N) where units are meters
nc_utm <- sf::st_transform(nc, 32617)
p_base <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina (UTM)", fill = "Area") +
ggplot2::theme_minimal()
# --- Example 1: Default style with automatic unit detection ---
# The function correctly detects the UTM projection's unit is 'm'.
# No need to specify `crs_unit`.
p_base +
annotation_scalebar(location = "bl")
# --- Load Required Libraries ---
if (require("ggplot2") && require("sf")) {
# --- Prepare Data ---
# Use the North Carolina shapefile included with the 'sf' package
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
# Transform to a projected CRS (UTM Zone 17N) where units are meters
nc_utm <- sf::st_transform(nc, 32617)
p_base <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina (UTM)", fill = "Area") +
ggplot2::theme_minimal()
# --- Example 1: Default style with automatic unit detection ---
# The function correctly detects the UTM projection's unit is 'm'.
# No need to specify `crs_unit`.
p_base +
annotation_scalebar(location = "bl")
# --- Prepare Data ---
# Use the North Carolina shapefile included with the 'sf' package
nc <- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
# Transform to a projected CRS (UTM Zone 17N) where units are meters
nc_utm <- sf::st_transform(nc, 32617)
p_base <- ggplot2::ggplot() +
ggplot2::geom_sf(data = nc_utm, ggplot2::aes(fill = AREA)) +
ggplot2::labs(title = "Map of North Carolina (UTM)", fill = "Area") +
ggplot2::theme_minimal()
# --- Example 1: Default style with automatic unit detection ---
# The function correctly detects the UTM projection's unit is 'm'.
# No need to specify `crs_unit`.
p_base +
annotation_scalebar(location = "bl")
# --- Example 3: Forcing display unit to meters ---
# The scale bar would auto-upgrade to 'km'. Here, we force it to stay in 'm'.
p_base +
annotation_scalebar(
location = "bl",
fixed_width = 100000,
display_unit = "m"
)
# --- Example 3: Forcing display unit to meters ---
# The scale bar would auto-upgrade to 'km'. Here, we force it to stay in 'm'.
p_base +
annotation_scalebar(
location = "bl",
fixed_width = 100,
display_unit = "km"
)
# --- Example 3: Forcing display unit to meters ---
# The scale bar would auto-upgrade to 'km'. Here, we force it to stay in 'm'.
p_base +
annotation_scalebar(
location = "bl",
fixed_width = 200,
display_unit = "km"
)
# --- Example 4: Customizing the "segment" style ---
p_base +
annotation_scalebar(
location = "br",
style = "segment",
segments = 3, # 3 major divisions
label_show = "all", # Show all labels
minor_tick_height = 0.5, # Minor ticks are 50% height
text_cex = 0.8,
pad_x = grid::unit(1, "cm")
)
# --- Example 5: Using the classic "bar" style ---
p_base +
annotation_scalebar(
location = "bl",
style = "bar",
bar_cols = c("grey10", "grey90")
)
}
# --- Example 5: Using the classic "bar" style ---
p_base +
annotation_scalebar(
location = "bl",
style = "bar",
bar_cols = c("grey10", "grey90")
)
# --- Example 3: Forcing display unit to meters ---
# The scale bar would auto-upgrade to 'km'. Here, we force it to stay in 'm'.
p_base +
annotation_scalebar(
location = "bl",
fixed_width = 200,
display_unit = "km"
)
